# Authors: Steffen Moeller and Sarah Fischer
#          University of Rostock, Germany, 2017

# Transformation of Venn object into an igraph
getVennGraph <- function(counts)
{

  if (!(is.matrix(counts) && ncol(counts)>=2 && colnames(counts)[1]=="num")) {
    stop("getVennGraph: counts argument is not formatted as expected to be generated by gplots::venn()")
  }

  # Matching if the graph representation is turned on and changing
  # the order of the intersections
  numSets <- ncol(counts)-1

  nodes.for.g=nrow(counts)
  venn.graph<-igraph::graph.empty(n=nodes.for.g, directed=TRUE)
  venn.graph<-igraph::set_vertex_attr(graph=venn.graph,"rowname",value=rownames(counts))
  venn.graph<-igraph::set_vertex_attr(graph=venn.graph,"label",  value=paste(counts[,"num"],
                                                                               rownames(counts),
                                                                               sep="")) # linebreak
  # to temporarily allow a confusion between rowname and index
  venn.graph<-igraph::set_vertex_attr(graph=venn.graph,"name",   value=rownames(counts))
   
  m <- cbind(counts[,1,drop=F],
             depth=apply(counts[,-1],1,sum),
             counts[,-1])
  for (m.column in colnames(m)) {
    venn.graph <- igraph::set_vertex_attr(graph=venn.graph,name=m.column,value=m[,m.column])
  }

  # helper function to be pointed to the element that has one element more
  add.set<-function(given,available) {
    if (is.list(given)) stop("gplots::getVennGraph: add_set only works with scalars and vectors")
    if (is.null(given) || any(is.na(given)) || 0==length(given)) {
      given <- c()
    }
    remainder <- available[! available %in% given]
    if (0 == length(remainder)) {
      #stop("Nothing remaining")
      return(remainder)
    }
    ret<-list()
    for(r in remainder) {
      v<-c(given,r)
      #print(v)
      ret<-c(ret,list(v))
    }
    ret
  }

  binarystring2numericarray <- function(X) {
    X.split<-strsplit(X,split="",fixed=T)
    lapply(X.split,function(X) which("1"==X))
  }

  numericarray2binarystring <- function(positions,length) {
    r <- rep(0,length)
    r[positions] <- 1
    paste(r,collapse="",sep="")
  }

  edges <- sapply(binarystring2numericarray(rownames(counts)),
                  function(from) {
                    to <- add.set(from,1:numSets)
                    from.string <- numericarray2binarystring(from,numSets)
                    return(t(sapply(to,
                                    function(t,from=from) {
                                      t.string <- numericarray2binarystring(t,numSets)
                                      return(c(from=from.string,to=t.string))
                                    }))
                          )
                   }
                  )

  for(i in 1:length(edges)) {
    i.matrix <- edges[[i]]
    if (0<length(i.matrix)) for(i.matrix.rowno in 1:nrow(i.matrix)) {
      from.index <- match(x=i.matrix[i.matrix.rowno,"from"],rownames(counts))
      to.index   <- match(x=i.matrix[i.matrix.rowno,"to"],  rownames(counts))
      venn.graph <- igraph::add_edges(graph=venn.graph, edges=c(from.index,to.index))
    }
  }
  igraph::V(venn.graph)$name <- igraph::V(venn.graph)$label
  venn.graph
}


# Colouring of graph nodes in analogy to polyominoes
venn.graph.colouring <- function(data,
                         col=NULL, col.scheme=rainbow, col.function=NULL,
                         debug=FALSE)
{
  if (is.null(data)) stop("venn.graph.colouring: is.null(data)")


  if (is.null(col)) {
    if (is.null(col.function)) {
      if(is.null(attr(data,"p.values"))){
        col.function=pV_colouringFeatureCount
      } else {
        col.function=pV_colouringPValue
      }
    }
  }

  if ("igraph" == class(data)) stop("venn.graph.colouring: Cannot colour igraph object")

  g <- attr(data,"graph")
  if (is.null(g)) {
    g <- getVennGraph(data)
    attr(data,"graph") <- g
  }
  if (!is.null(col) && !is.null(col.function)) {
    warning(paste("venn.graph.colouring: conflict between homogeneous colouring",
                  "with 'col' and individualised colours with 'col.function'.",
                  "Not colouring."))
    return(data)
  }
  
  if (!is.null(col)) igraph::V(g)$color <- col
  if (!is.null(col.function)) {
    if (is.null(igraph::V(g)$rowname)) {
       stop("venn.graph.colouring: Expecting binary rownames as graph attributes")
    }
    igraph::V(g)$color <- rep(NA,length(igraph::V(g)))
    col.scheme.res <- col.scheme(min(32,length(igraph::V(g)))) # more colours than a human interprets
    if (debug) {cat("col.scheme.res="); print(col.scheme.res)}
    col.function.res <- sapply(igraph::V(g)$rowname,col.function,data=data)
    col.function.maxmin <- max(col.function.res)-min(col.function.res)
    if (debug) {cat("col.function.res="); print(col.function.res)}
    col.schema.indices <- 1+round((col.function.res-min(col.function.res))/max(1,col.function.maxmin-1)*(length(col.scheme.res)-1))
    if (debug) {cat("col.schema.indices="); print(col.schema.indices)}
    igraph::V(g)$color <- col.scheme.res[col.schema.indices]
  }
  g
}


venn.graph.simplify <- function(graph,simplification=NULL,verbose=F,...)
{
  if (is.null(graph)) stop("venn.graph.simplify: graph attribute is null")
  if ("igraph" != class(graph)) stop("venn.graph.simplify: expecting graph attribute to be an igraph object")

  if (is.null(simplification)) {
    warning("venn.graph.simplify: not requesting simplification, skipping.")
    return(graph)
  }

  if (length(simplification)>1) {
    if (is.array(simplification) || is.vector(simplification)) {
      for (i in 1:length(simplification)) {
        graph <- venn.graph.simplify(graph,simplification[i],...)
      }
    } else if (is.list(simplification)) {
      for (i in 1:length(simplification)) {
         graph <- venn.graph.simplify(graph,simplification[[i]],...)
      }
    }
  } else if (is.function(simplification)) {
    graph <- simplification(graph,...)
  } else if (is.character(simplification)) {
    if ("noUniverse"==simplification) {
       if (is.null(V(graph)$rowname)) {
         warning("venn.graph.simplify: Nodes have no rowname attribute, cannot filter out universe")
       } else {
         if (verbose) cat("venn.graph.simplify: removing 0 (bottom) node")
         graph <- igraph::delete.vertices(graph,which(grepl(V(graph)$rowname,pattern="^0*$")))
       }
    } else if ("minNum1"==simplification) {
       if (is.null(V(graph)$num)) {
         warning("venn.graph.simplify: Nodes have no num attribute, cannot filter for abundance")
       } else {
         if (verbose) cat("venn.graph.simplify: removing nodes with zero value")
         graph <- igraph::delete.vertices(graph,which(igraph::V(graph)$num<1))
       }
    }
  } else if (is.logical(simplification)) {
    if (simplification) {
      graph <- venn.graph.simplify(graph,c("noUniverse","minNum1"))
    }
  } else {
    stop(paste("venn.graph.simplify: Do not know how to work with simplification of class '",
               class(simplification),"'.",sep=""))
  }
  graph
}

